package main

import (
	"bytes"
	"fmt"
	"gitee.com/pengdacn/protoc-gen-go-kratos-selector/selector"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"path"
	"sort"
	"strconv"
)

const (
	suffix = "_selector.pb.go"
)

func generateSelector(gen *protogen.Plugin) error {
	var srvs []serviceDesc
	for _, file := range gen.Files {
		if !file.Generate {
			continue
		}

		descs, err := parse(file)
		if err != nil {
			return err
		}

		srvs = append(srvs, descs...)
	}

	// 查找所有需要用到的defined文件
	usages := make(map[string][]*serviceDesc)
	for i := 0; i < len(srvs); i++ {
		srv := &srvs[i]

		descs := usages[srv.selectInfo.Use]
		descs = append(descs, srv)

		usages[srv.selectInfo.Use] = descs
	}

	if len(usages) == 0 {
		return nil
	}

	// 生成selector文件
genFile:
	for p, srvs := range usages {
		for _, file := range gen.Files {
			if file.Desc.Path() == p {
				if err := generateSelectorFile(gen, file, srvs); err != nil {
					return err
				}

				continue genFile
			}
		}

		return fmt.Errorf("not found import file: %s", p)
	}

	return nil
}

func generateSelectorFile(gen *protogen.Plugin, file *protogen.File, srvs []*serviceDesc) error {
	extension, ok := proto.GetExtension(file.Desc.Options(), selector.E_Defined).(*selector.Defined)
	if extension == nil || !ok {
		return fmt.Errorf("file: %s; not found select defined", file.Desc.Path())
	}

	// 检查id是否在selector文件中定义
	var useHandle = make(map[string]struct{})
	for _, srv := range srvs {
		for _, verb := range srv.selectInfo.Verbs {
			useHandle[verb.Id] = struct{}{}
		}
	}

find:
	for name := range useHandle {
		for _, handle := range extension.Handlers {
			if handle.Id == name {
				if handle.Property < 0 {
					return fmt.Errorf("%s:%s property than less zero", file.Desc.Path(), handle.Id)
				}

				continue find
			}
		}

		return fmt.Errorf("selector id: %s not found", name)
	}

	// TODO 想办法合并操作
	for _, handler := range extension.Handlers {
		if handler.Property < 0 {
			return fmt.Errorf("%s:%s property than less zero", file.Desc.Path(), handler.Id)
		}
	}

	filename := file.GeneratedFilenamePrefix + suffix
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P("// Code generated by proto-gen-go-kratos-selector. DO NOT EDIT.")
	g.P("// versions:")
	g.P(fmt.Sprintf("// proto-gen-go-kratos-selector %s", release))
	g.P(`// url:`)
	g.P(`// https://gitee.com/pengdacn/protoc-gen-go-kratos-selector`)
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()

	data := generateDrawingData(extension, srvs)

	bs := bytes.NewBuffer(nil)
	err := tmpl.Execute(bs, &data)
	if err != nil {
		return err
	}

	g.P(bs.String())

	return nil
}

type DrawingData struct {
	Name     string
	Handlers []struct {
		Name           string
		FullMethodName []string
	}
}

func generateDrawingData(def *selector.Defined, srvs []*serviceDesc) (r DrawingData) {
	r.Name = def.Name

	sort.Slice(def.Handlers, func(i, j int) bool {
		pre := def.Handlers[i]
		prov := def.Handlers[j]

		switch {
		case pre.Property == prov.Property:
			return pre.Id < prov.Id
		default:
			return def.Handlers[i].Property < def.Handlers[j].Property
		}
	})

	t := make(map[string][]string)
	for _, srv := range srvs {
		var verb = srv.selectInfo.Verbs
		{
			// 添加自动导入verb
			var autoImport []*selector.Verb
			for _, handler := range def.Handlers {
				if handler.AutoImport {
					if !exitsHandleIdInServiceDesc(srv, handler.Id) {
						autoImport = append(autoImport, &selector.Verb{
							Id:     handler.Id,
							Select: handler.PreSelect,
						})
					}
				}
			}

			if len(autoImport) != 0 {
				verb = append(verb, autoImport...)
			}
		}

		for _, verb := range verb {
			var (
				matches []string
				vSelect = verb.Select
			)

			if vSelect == "" {
				h, ok := getHandle(def, verb.Id)
				if ok {
					// 按照现在的逻辑，这个ok永远等于true
					if h.PreSelect != "" {
						vSelect = h.PreSelect
					}
				}
			}

			for _, desc := range srv.funcs {
				if fullMatch(vSelect, desc.tags) {
					matches = append(matches, path.Join("/", srv.protoFullName, desc.protoName))
				}
			}

			newMatches := t[verb.Id]
			if len(matches) != 0 {
				newMatches = append(newMatches, matches...)
				t[verb.Id] = newMatches
			}
		}
	}

	nameCount := make(map[string]int)
	for _, handle := range def.Handlers {
		if handle.Disable {
			continue
		}

		name := handle.Id
		if handle.Alias != "" {
			name = handle.Alias
		}

		c := nameCount[name]

		finalName := name
		if c != 0 {
			finalName = name + "_" + strconv.Itoa(c)
		}

		c++
		nameCount[name] = c

		handlers := t[handle.Id]

		sort.Strings(handlers)

		r.Handlers = append(r.Handlers, struct {
			Name           string
			FullMethodName []string
		}{Name: finalName, FullMethodName: handlers})
	}

	return
}

func getHandle(exts *selector.Defined, id string) (*selector.Handle, bool) {
	for _, handler := range exts.Handlers {
		if handler.Id == id {
			return handler, true
		}
	}

	return nil, false
}

func exitsHandleIdInServiceDesc(srv *serviceDesc, id string) bool {
	for _, verb := range srv.selectInfo.Verbs {
		if verb.Id == id {
			return true
		}
	}

	return false
}
